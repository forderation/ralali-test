// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"context"
	"github.com/forderation/ralali-test/internal/model"
	"sync"
)

// Ensure, that CakeDBInterfaceMock does implement CakeDBInterface.
// If this is not the case, regenerate this file with moq.
var _ CakeDBInterface = &CakeDBInterfaceMock{}

// CakeDBInterfaceMock is a mock implementation of CakeDBInterface.
//
//	func TestSomethingThatUsesCakeDBInterface(t *testing.T) {
//
//		// make and configure a mocked CakeDBInterface
//		mockedCakeDBInterface := &CakeDBInterfaceMock{
//			CountCakesFunc: func(ctx context.Context) (int64, error) {
//				panic("mock out the CountCakes method")
//			},
//			GetCakeFunc: func(ctx context.Context, id int) (*model.Cake, error) {
//				panic("mock out the GetCake method")
//			},
//			GetCakesFunc: func(ctx context.Context, param model.GetCakesQuery) ([]model.Cake, error) {
//				panic("mock out the GetCakes method")
//			},
//			InsertCakeFunc: func(ctx context.Context, param model.CakePayloadQuery) error {
//				panic("mock out the InsertCake method")
//			},
//			SoftDeleteCakeFunc: func(ctx context.Context, id int) error {
//				panic("mock out the SoftDeleteCake method")
//			},
//			UpdateCakeFunc: func(ctx context.Context, id int, param model.CakePayloadQuery) error {
//				panic("mock out the UpdateCake method")
//			},
//		}
//
//		// use mockedCakeDBInterface in code that requires CakeDBInterface
//		// and then make assertions.
//
//	}
type CakeDBInterfaceMock struct {
	// CountCakesFunc mocks the CountCakes method.
	CountCakesFunc func(ctx context.Context) (int64, error)

	// GetCakeFunc mocks the GetCake method.
	GetCakeFunc func(ctx context.Context, id int) (*model.Cake, error)

	// GetCakesFunc mocks the GetCakes method.
	GetCakesFunc func(ctx context.Context, param model.GetCakesQuery) ([]model.Cake, error)

	// InsertCakeFunc mocks the InsertCake method.
	InsertCakeFunc func(ctx context.Context, param model.CakePayloadQuery) error

	// SoftDeleteCakeFunc mocks the SoftDeleteCake method.
	SoftDeleteCakeFunc func(ctx context.Context, id int) error

	// UpdateCakeFunc mocks the UpdateCake method.
	UpdateCakeFunc func(ctx context.Context, id int, param model.CakePayloadQuery) error

	// calls tracks calls to the methods.
	calls struct {
		// CountCakes holds details about calls to the CountCakes method.
		CountCakes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetCake holds details about calls to the GetCake method.
		GetCake []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int
		}
		// GetCakes holds details about calls to the GetCakes method.
		GetCakes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Param is the param argument value.
			Param model.GetCakesQuery
		}
		// InsertCake holds details about calls to the InsertCake method.
		InsertCake []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Param is the param argument value.
			Param model.CakePayloadQuery
		}
		// SoftDeleteCake holds details about calls to the SoftDeleteCake method.
		SoftDeleteCake []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int
		}
		// UpdateCake holds details about calls to the UpdateCake method.
		UpdateCake []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int
			// Param is the param argument value.
			Param model.CakePayloadQuery
		}
	}
	lockCountCakes     sync.RWMutex
	lockGetCake        sync.RWMutex
	lockGetCakes       sync.RWMutex
	lockInsertCake     sync.RWMutex
	lockSoftDeleteCake sync.RWMutex
	lockUpdateCake     sync.RWMutex
}

// CountCakes calls CountCakesFunc.
func (mock *CakeDBInterfaceMock) CountCakes(ctx context.Context) (int64, error) {
	if mock.CountCakesFunc == nil {
		panic("CakeDBInterfaceMock.CountCakesFunc: method is nil but CakeDBInterface.CountCakes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountCakes.Lock()
	mock.calls.CountCakes = append(mock.calls.CountCakes, callInfo)
	mock.lockCountCakes.Unlock()
	return mock.CountCakesFunc(ctx)
}

// CountCakesCalls gets all the calls that were made to CountCakes.
// Check the length with:
//
//	len(mockedCakeDBInterface.CountCakesCalls())
func (mock *CakeDBInterfaceMock) CountCakesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountCakes.RLock()
	calls = mock.calls.CountCakes
	mock.lockCountCakes.RUnlock()
	return calls
}

// GetCake calls GetCakeFunc.
func (mock *CakeDBInterfaceMock) GetCake(ctx context.Context, id int) (*model.Cake, error) {
	if mock.GetCakeFunc == nil {
		panic("CakeDBInterfaceMock.GetCakeFunc: method is nil but CakeDBInterface.GetCake was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetCake.Lock()
	mock.calls.GetCake = append(mock.calls.GetCake, callInfo)
	mock.lockGetCake.Unlock()
	return mock.GetCakeFunc(ctx, id)
}

// GetCakeCalls gets all the calls that were made to GetCake.
// Check the length with:
//
//	len(mockedCakeDBInterface.GetCakeCalls())
func (mock *CakeDBInterfaceMock) GetCakeCalls() []struct {
	Ctx context.Context
	ID  int
} {
	var calls []struct {
		Ctx context.Context
		ID  int
	}
	mock.lockGetCake.RLock()
	calls = mock.calls.GetCake
	mock.lockGetCake.RUnlock()
	return calls
}

// GetCakes calls GetCakesFunc.
func (mock *CakeDBInterfaceMock) GetCakes(ctx context.Context, param model.GetCakesQuery) ([]model.Cake, error) {
	if mock.GetCakesFunc == nil {
		panic("CakeDBInterfaceMock.GetCakesFunc: method is nil but CakeDBInterface.GetCakes was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Param model.GetCakesQuery
	}{
		Ctx:   ctx,
		Param: param,
	}
	mock.lockGetCakes.Lock()
	mock.calls.GetCakes = append(mock.calls.GetCakes, callInfo)
	mock.lockGetCakes.Unlock()
	return mock.GetCakesFunc(ctx, param)
}

// GetCakesCalls gets all the calls that were made to GetCakes.
// Check the length with:
//
//	len(mockedCakeDBInterface.GetCakesCalls())
func (mock *CakeDBInterfaceMock) GetCakesCalls() []struct {
	Ctx   context.Context
	Param model.GetCakesQuery
} {
	var calls []struct {
		Ctx   context.Context
		Param model.GetCakesQuery
	}
	mock.lockGetCakes.RLock()
	calls = mock.calls.GetCakes
	mock.lockGetCakes.RUnlock()
	return calls
}

// InsertCake calls InsertCakeFunc.
func (mock *CakeDBInterfaceMock) InsertCake(ctx context.Context, param model.CakePayloadQuery) error {
	if mock.InsertCakeFunc == nil {
		panic("CakeDBInterfaceMock.InsertCakeFunc: method is nil but CakeDBInterface.InsertCake was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Param model.CakePayloadQuery
	}{
		Ctx:   ctx,
		Param: param,
	}
	mock.lockInsertCake.Lock()
	mock.calls.InsertCake = append(mock.calls.InsertCake, callInfo)
	mock.lockInsertCake.Unlock()
	return mock.InsertCakeFunc(ctx, param)
}

// InsertCakeCalls gets all the calls that were made to InsertCake.
// Check the length with:
//
//	len(mockedCakeDBInterface.InsertCakeCalls())
func (mock *CakeDBInterfaceMock) InsertCakeCalls() []struct {
	Ctx   context.Context
	Param model.CakePayloadQuery
} {
	var calls []struct {
		Ctx   context.Context
		Param model.CakePayloadQuery
	}
	mock.lockInsertCake.RLock()
	calls = mock.calls.InsertCake
	mock.lockInsertCake.RUnlock()
	return calls
}

// SoftDeleteCake calls SoftDeleteCakeFunc.
func (mock *CakeDBInterfaceMock) SoftDeleteCake(ctx context.Context, id int) error {
	if mock.SoftDeleteCakeFunc == nil {
		panic("CakeDBInterfaceMock.SoftDeleteCakeFunc: method is nil but CakeDBInterface.SoftDeleteCake was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSoftDeleteCake.Lock()
	mock.calls.SoftDeleteCake = append(mock.calls.SoftDeleteCake, callInfo)
	mock.lockSoftDeleteCake.Unlock()
	return mock.SoftDeleteCakeFunc(ctx, id)
}

// SoftDeleteCakeCalls gets all the calls that were made to SoftDeleteCake.
// Check the length with:
//
//	len(mockedCakeDBInterface.SoftDeleteCakeCalls())
func (mock *CakeDBInterfaceMock) SoftDeleteCakeCalls() []struct {
	Ctx context.Context
	ID  int
} {
	var calls []struct {
		Ctx context.Context
		ID  int
	}
	mock.lockSoftDeleteCake.RLock()
	calls = mock.calls.SoftDeleteCake
	mock.lockSoftDeleteCake.RUnlock()
	return calls
}

// UpdateCake calls UpdateCakeFunc.
func (mock *CakeDBInterfaceMock) UpdateCake(ctx context.Context, id int, param model.CakePayloadQuery) error {
	if mock.UpdateCakeFunc == nil {
		panic("CakeDBInterfaceMock.UpdateCakeFunc: method is nil but CakeDBInterface.UpdateCake was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		ID    int
		Param model.CakePayloadQuery
	}{
		Ctx:   ctx,
		ID:    id,
		Param: param,
	}
	mock.lockUpdateCake.Lock()
	mock.calls.UpdateCake = append(mock.calls.UpdateCake, callInfo)
	mock.lockUpdateCake.Unlock()
	return mock.UpdateCakeFunc(ctx, id, param)
}

// UpdateCakeCalls gets all the calls that were made to UpdateCake.
// Check the length with:
//
//	len(mockedCakeDBInterface.UpdateCakeCalls())
func (mock *CakeDBInterfaceMock) UpdateCakeCalls() []struct {
	Ctx   context.Context
	ID    int
	Param model.CakePayloadQuery
} {
	var calls []struct {
		Ctx   context.Context
		ID    int
		Param model.CakePayloadQuery
	}
	mock.lockUpdateCake.RLock()
	calls = mock.calls.UpdateCake
	mock.lockUpdateCake.RUnlock()
	return calls
}
